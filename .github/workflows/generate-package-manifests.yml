name: Generate Package Manager Manifests

# This workflow generates package manager files (WinGet, Homebrew Cask, APT) and optionally
# creates Pull Requests in the respective repositories.
#
# Triggers:
# - Manual: workflow_dispatch with optional version and create_prs flag
# - Automatic: release event (published) - automatically creates PRs
#
# Prerequisites for PR creation:
# 1. Create forks of the target repositories:
#    - Fork microsoft/winget-pkgs: https://github.com/microsoft/winget-pkgs/fork
#    - Fork homebrew/homebrew-cask: https://github.com/homebrew/homebrew-cask/fork
# 2. Create a Personal Access Token (PAT) with 'repo' scope
# 3. Add PAT as secret 'PACKAGE_MANAGER_PAT' in repository settings
#
# Usage:
# - Manual run: Go to Actions -> Generate Package Manager Manifests -> Run workflow
#   - Set version (optional): e.g., v0.2.3 or leave empty for latest
#   - Set create_prs: true to automatically create PRs in WinGet and Homebrew repos
#   - Set fork_owner (optional): GitHub username who owns the forks (auto-detected from PAT)
# - Automatic: Triggers automatically when a release is published

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.2.3) - leave empty for latest release'
        required: false
        type: string
      create_prs:
        description: 'Automatically create PRs in WinGet and Homebrew repositories'
        required: false
        type: boolean
        default: false
      fork_owner:
        description: 'GitHub username who owns the fork (required for PR creation)'
        required: false
        type: string
  release:
    types: [published]

permissions:
  contents: read
  pull-requests: write

jobs:
  prepare-artifacts:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      msi_url: ${{ steps.get_artifacts.outputs.msi_url }}
      msi_size: ${{ steps.get_artifacts.outputs.msi_size }}
      msi_sha256: ${{ steps.checksums.outputs.msi_sha256 }}
      dmg_url: ${{ steps.get_artifacts.outputs.dmg_url }}
      dmg_size: ${{ steps.get_artifacts.outputs.dmg_size }}
      dmg_sha256: ${{ steps.checksums.outputs.dmg_sha256 }}
      deb_url: ${{ steps.get_artifacts.outputs.deb_url }}
      deb_size: ${{ steps.get_artifacts.outputs.deb_size }}
      deb_sha256: ${{ steps.checksums.outputs.deb_sha256 }}
      release_id: ${{ steps.get_artifacts.outputs.release_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version
        id: get_version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            # Get version from release event
            TAG="${{ github.event.release.tag_name }}"
            VERSION=${TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            # Remove 'v' prefix if present
            VERSION=${VERSION#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          else
            # Get latest release using GitHub API
            LATEST_RELEASE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            LATEST_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
            VERSION=${LATEST_TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $VERSION"

      - name: Get release artifacts
        id: get_artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_version.outputs.tag }}
          VERSION: ${{ steps.get_version.outputs.version }}
        run: |
          # Get release by tag using GitHub API
          RELEASE_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${TAG}")
          
          RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r '.id')
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          
          # Check if release exists
          if [ "$RELEASE_ID" == "null" ] || [ -z "$RELEASE_ID" ]; then
            echo "::error::Release not found for tag: ${TAG}"
            exit 1
          fi
          
          echo "Processing release ${TAG} (version ${VERSION})"
          echo "Available assets:"
          echo "$RELEASE_JSON" | jq -r '.assets[] | "  - \(.name)"'
          
          # Find MSI file - verify it matches the version
          # Look for MSI files that contain the version number in the filename
          MSI_ASSET=$(echo "$RELEASE_JSON" | jq -r --arg version "$VERSION" \
            '.assets[] | select(.name | endswith(".msi") and contains($version)) | .')
          
          if [ -z "$MSI_ASSET" ] || [ "$MSI_ASSET" == "null" ]; then
            # Fallback: try to find any MSI file if version-specific one not found
            echo "::warning::No MSI file found matching version ${VERSION}, trying fallback..."
            MSI_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".msi")) | .')
          fi
          
          if [ -n "$MSI_ASSET" ] && [ "$MSI_ASSET" != "null" ]; then
            MSI_NAME=$(echo "$MSI_ASSET" | jq -r '.name')
            MSI_URL=$(echo "$MSI_ASSET" | jq -r '.browser_download_url')
            MSI_SIZE=$(echo "$MSI_ASSET" | jq -r '.size')
            
            # Verify version matches
            if [[ "$MSI_NAME" != *"$VERSION"* ]]; then
              echo "::error::MSI filename '$MSI_NAME' does not contain version '$VERSION'"
              echo "::error::This mismatch will break installs and SHA validation"
              exit 1
            fi
            
            echo "msi_url=$MSI_URL" >> $GITHUB_OUTPUT
            echo "msi_size=$MSI_SIZE" >> $GITHUB_OUTPUT
            echo "✅ Found MSI matching version ${VERSION}: $MSI_NAME"
          fi
          
          # Find DMG file - verify it matches the version
          DMG_ASSET=$(echo "$RELEASE_JSON" | jq -r --arg version "$VERSION" \
            '.assets[] | select(.name | endswith(".dmg") and contains($version)) | .')
          
          if [ -z "$DMG_ASSET" ] || [ "$DMG_ASSET" == "null" ]; then
            # Fallback: try to find any DMG file if version-specific one not found
            echo "::warning::No DMG file found matching version ${VERSION}, trying fallback..."
            DMG_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".dmg")) | .')
          fi
          
          if [ -n "$DMG_ASSET" ] && [ "$DMG_ASSET" != "null" ]; then
            DMG_NAME=$(echo "$DMG_ASSET" | jq -r '.name')
            DMG_URL=$(echo "$DMG_ASSET" | jq -r '.browser_download_url')
            DMG_SIZE=$(echo "$DMG_ASSET" | jq -r '.size')
            
            # Verify version matches
            if [[ "$DMG_NAME" != *"$VERSION"* ]]; then
              echo "::error::DMG filename '$DMG_NAME' does not contain version '$VERSION'"
              echo "::error::This mismatch will break installs and SHA validation"
              exit 1
            fi
            
            echo "dmg_url=$DMG_URL" >> $GITHUB_OUTPUT
            echo "dmg_size=$DMG_SIZE" >> $GITHUB_OUTPUT
            echo "✅ Found DMG matching version ${VERSION}: $DMG_NAME"
          fi
          
          # Find DEB file - verify it matches the version
          DEB_ASSET=$(echo "$RELEASE_JSON" | jq -r --arg version "$VERSION" \
            '.assets[] | select(.name | endswith(".deb") and contains($version)) | .')
          
          if [ -z "$DEB_ASSET" ] || [ "$DEB_ASSET" == "null" ]; then
            # Fallback: try to find any DEB file if version-specific one not found
            echo "::warning::No DEB file found matching version ${VERSION}, trying fallback..."
            DEB_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".deb")) | .')
          fi
          
          if [ -n "$DEB_ASSET" ] && [ "$DEB_ASSET" != "null" ]; then
            DEB_NAME=$(echo "$DEB_ASSET" | jq -r '.name')
            DEB_URL=$(echo "$DEB_ASSET" | jq -r '.browser_download_url')
            DEB_SIZE=$(echo "$DEB_ASSET" | jq -r '.size')
            
            # Verify version matches
            if [[ "$DEB_NAME" != *"$VERSION"* ]]; then
              echo "::error::DEB filename '$DEB_NAME' does not contain version '$VERSION'"
              echo "::error::This mismatch will break installs and SHA validation"
              exit 1
            fi
            
            echo "deb_url=$DEB_URL" >> $GITHUB_OUTPUT
            echo "deb_size=$DEB_SIZE" >> $GITHUB_OUTPUT
            echo "✅ Found DEB matching version ${VERSION}: $DEB_NAME"
          fi

      - name: Download and calculate checksums
        id: checksums
        run: |
          mkdir -p artifacts
          
          # Download MSI and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.msi_url }}" ]; then
            curl -L -o artifacts/installer.msi "${{ steps.get_artifacts.outputs.msi_url }}"
            MSI_SHA256=$(sha256sum artifacts/installer.msi | cut -d' ' -f1)
            echo "msi_sha256=$MSI_SHA256" >> $GITHUB_OUTPUT
            echo "MSI SHA-256: $MSI_SHA256"
          fi
          
          # Download DMG and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.dmg_url }}" ]; then
            curl -L -o artifacts/installer.dmg "${{ steps.get_artifacts.outputs.dmg_url }}"
            DMG_SHA256=$(sha256sum artifacts/installer.dmg | cut -d' ' -f1)
            echo "dmg_sha256=$DMG_SHA256" >> $GITHUB_OUTPUT
            echo "DMG SHA-256: $DMG_SHA256"
          fi
          
          # Download DEB and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.deb_url }}" ]; then
            curl -L -o artifacts/installer.deb "${{ steps.get_artifacts.outputs.deb_url }}"
            DEB_SHA256=$(sha256sum artifacts/installer.deb | cut -d' ' -f1)
            echo "deb_sha256=$DEB_SHA256" >> $GITHUB_OUTPUT
            echo "DEB SHA-256: $DEB_SHA256"
          fi

  generate-winget:
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.msi_url != ''
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get app metadata
        id: metadata
        run: |
          # Read from tauri.conf.json using PowerShell
          $config = Get-Content -Path "backend\tauri.conf.json" -Raw | ConvertFrom-Json
          
          $PRODUCT_NAME = $config.package.productName
          $DESCRIPTION = $config.tauri.bundle.longDescription
          $SHORT_DESC = $config.tauri.bundle.shortDescription
          
          Add-Content -Path $env:GITHUB_OUTPUT -Value "product_name=$PRODUCT_NAME"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "description=$DESCRIPTION"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "short_description=$SHORT_DESC"
          
          # Publisher and path: winget uses manifests/<letter>/<publisher>/<package>/<version>
          # Path will be: manifests/t/tmtrckr/TimeTracker/<version>/
          $PUBLISHER = "tmtrckr"
          $WINGET_PATH_LETTER = "t"
          $PACKAGE_ID = "$PUBLISHER.$PRODUCT_NAME"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "publisher=$PUBLISHER"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "package_id=$PACKAGE_ID"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "winget_path_letter=$WINGET_PATH_LETTER"

      - name: Create manifest directory structure
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PATH_LETTER = "${{ steps.metadata.outputs.winget_path_letter }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PACKAGE_NAME = "${{ steps.metadata.outputs.product_name }}"
          
          # Create directory: manifests/t/tmtrckr/TimeTracker/<version>/
          # Structure: manifests/<letter>/<publisher>/<PackageName>/<Version>/
          New-Item -ItemType Directory -Force -Path "manifests\$PATH_LETTER\$PUBLISHER\$PACKAGE_NAME\$VERSION" | Out-Null

      - name: Generate locale manifest
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          $DESCRIPTION = "${{ steps.metadata.outputs.description }}"
          $SHORT_DESC = "${{ steps.metadata.outputs.short_description }}"
          
          # Filename format: <PackageIdentifier>.locale.<language-code>.yaml
          $LOCALE_FILENAME = "$PACKAGE_ID.locale.en-US.yaml"
          $PATH_LETTER = "${{ steps.metadata.outputs.winget_path_letter }}"
          $MANIFEST_PATH = "manifests\$PATH_LETTER\$PUBLISHER\$PRODUCT_NAME\$VERSION\$LOCALE_FILENAME"
          
          # Generate defaultLocale manifest according to multi-file schema v1.10.0
          # Field order: PackageIdentifier, PackageVersion, PackageLocale, Publisher, PublisherUrl, 
          # PublisherSupportUrl, Author, PackageName, PackageUrl, License, LicenseUrl, Copyright, 
          # CopyrightUrl, ShortDescription, Description, Tags, Moniker, ManifestType, ManifestVersion
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "PackageVersion: $VERSION`n"
          $manifestContent += "PackageLocale: en-US`n"
          $manifestContent += "Publisher: $PUBLISHER`n"
          $manifestContent += "PublisherUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "PublisherSupportUrl: https://github.com/${{ github.repository }}/issues`n"
          $manifestContent += "Author: $PUBLISHER`n"
          $manifestContent += "PackageName: $PRODUCT_NAME`n"
          $manifestContent += "PackageUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "License: MIT`n"
          $manifestContent += "LicenseUrl: https://github.com/${{ github.repository }}/blob/main/LICENSE`n"
          $manifestContent += "Copyright: Copyright (c) 2026 tmtrckr`n"
          $manifestContent += "CopyrightUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "ShortDescription: $SHORT_DESC`n"
          $manifestContent += "Description: $DESCRIPTION`n"
          $manifestContent += "Tags:`n"
          $manifestContent += "  - time-tracking`n"
          $manifestContent += "  - productivity`n"
          $manifestContent += "  - time-management`n"
          $manifestContent += "Moniker: timetracker`n"
          $manifestContent += "ManifestType: defaultLocale`n"
          $manifestContent += "ManifestVersion: 1.10.0`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Generate installer manifest
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          $MSI_URL = "${{ needs.prepare-artifacts.outputs.msi_url }}"
          $MSI_SHA256 = "${{ needs.prepare-artifacts.outputs.msi_sha256 }}"
          
          # Filename format: <PackageIdentifier>.installer.yaml
          $INSTALLER_FILENAME = "$PACKAGE_ID.installer.yaml"
          $PATH_LETTER = "${{ steps.metadata.outputs.winget_path_letter }}"
          $MANIFEST_PATH = "manifests\$PATH_LETTER\$PUBLISHER\$PRODUCT_NAME\$VERSION\$INSTALLER_FILENAME"
          
          # Generate installer manifest according to multi-file schema v1.10.0
          # Field order: PackageIdentifier, PackageVersion, Installers, ManifestType, ManifestVersion
          # Note: MSI installers have default silent switches, so InstallerSwitches are omitted
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "PackageVersion: $VERSION`n"
          $manifestContent += "Installers:`n"
          $manifestContent += "  - InstallerType: msi`n"
          $manifestContent += "    Architecture: x64`n"
          $manifestContent += "    InstallerUrl: $MSI_URL`n"
          $manifestContent += "    InstallerSha256: $MSI_SHA256`n"
          $manifestContent += "    InstallModes:`n"
          $manifestContent += "      - silent`n"
          $manifestContent += "      - silentWithProgress`n"
          $manifestContent += "    Scope: machine`n"
          $manifestContent += "ManifestType: installer`n"
          $manifestContent += "ManifestVersion: 1.10.0`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Generate version manifest
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          
          # Filename format: <PackageIdentifier>.yaml
          $VERSION_FILENAME = "$PACKAGE_ID.yaml"
          $PATH_LETTER = "${{ steps.metadata.outputs.winget_path_letter }}"
          $MANIFEST_PATH = "manifests\$PATH_LETTER\$PUBLISHER\$PRODUCT_NAME\$VERSION\$VERSION_FILENAME"
          
          # Generate version manifest according to multi-file schema v1.10.0
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "PackageVersion: $VERSION`n"
          $manifestContent += "DefaultLocale: en-US`n"
          $manifestContent += "ManifestType: version`n"
          $manifestContent += "ManifestVersion: 1.10.0`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Create winget manifest archive
        run: |
          Compress-Archive -Path "manifests" -DestinationPath "winget-manifests.zip" -Force

      - name: Upload WinGet manifests artifact
        uses: actions/upload-artifact@v4
        with:
          name: winget-manifests
          path: winget-manifests.zip
          retention-days: 30

  generate-homebrew:
    # NOTE: Cask file is generated but PR creation is disabled
    # Homebrew Cask requires signed and notarized DMG files
    # The cask file is still generated for future use when signing is configured
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.dmg_url != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get app metadata
        id: metadata
        run: |
          # Read from tauri.conf.json
          PRODUCT_NAME=$(node -p "require('./backend/tauri.conf.json').package.productName")
          LONG_DESC=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.longDescription")
          SHORT_DESC=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.shortDescription")
          IDENTIFIER=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.identifier")
          
          # Use short description for Homebrew (max 80 chars recommended, but can be longer)
          # Homebrew allows up to 80 chars for desc, but will accept longer
          DESCRIPTION="$SHORT_DESC"
          
          # Ensure description is not empty
          if [ -z "$DESCRIPTION" ] || [ "$DESCRIPTION" = "null" ]; then
            DESCRIPTION="Desktop time tracking application"
          fi
          
          # Remove any newlines and extra spaces
          DESCRIPTION=$(echo "$DESCRIPTION" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
          
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "long_description=$LONG_DESC" >> $GITHUB_OUTPUT
          echo "identifier=$IDENTIFIER" >> $GITHUB_OUTPUT
          
          # Cask name (lowercase, no spaces)
          CASK_NAME="timetracker"
          echo "cask_name=$CASK_NAME" >> $GITHUB_OUTPUT

      - name: Generate Homebrew Cask file
        env:
          VERSION: ${{ needs.prepare-artifacts.outputs.version }}
          CASK_NAME: ${{ steps.metadata.outputs.cask_name }}
          PRODUCT_NAME: ${{ steps.metadata.outputs.product_name }}
          DESCRIPTION: ${{ steps.metadata.outputs.description }}
          IDENTIFIER: ${{ steps.metadata.outputs.identifier }}
          DMG_URL: ${{ needs.prepare-artifacts.outputs.dmg_url }}
          DMG_SHA256: ${{ needs.prepare-artifacts.outputs.dmg_sha256 }}
          REPO_URL: https://github.com/${{ github.repository }}
        run: |
          # Generate cask file using Ruby for proper string escaping
          ruby << 'RUBYSCRIPT'
          require 'erb'
          
          cask_name = ENV['CASK_NAME']
          version = ENV['VERSION']
          url = ENV['DMG_URL']
          name = ENV['PRODUCT_NAME']
          desc = ENV['DESCRIPTION']
          homepage = ENV['REPO_URL']
          identifier = ENV['IDENTIFIER']
          
          # Ensure description doesn't exceed Homebrew limits
          desc = desc[0, 80] if desc.length > 80
          
          # Always use :no_check for GitHub Releases URLs
          # Homebrew requires :no_check when URL doesn't contain version in filename
          # GitHub Releases URLs have version in path but not in filename, so :no_check is required
          use_no_check = true
          
          template = <<~TEMPLATE
          # typed: false
          # frozen_string_literal: true
          
          # This file was generated by GitHub Actions
          # Do not edit this file manually
          
          # Note: This cask requires the DMG to be signed and notarized by Apple
          # for Homebrew Cask acceptance. Please ensure your releases are properly
          # signed before submitting PRs to homebrew/homebrew-cask.
          
          cask "<%= cask_name %>" do
            version "<%= version %>"
          <% if use_no_check %>
            sha256 :no_check
          <% else %>
            sha256 "<%= ENV['DMG_SHA256'] %>"
          <% end %>
          
            url "<%= url %>"
            name "<%= name %>"
            desc "<%= desc %>"
            homepage "<%= homepage %>"
          
            livecheck do
              url "<%= homepage %>"
              strategy :github_latest
            end
          
            app "<%= name %>.app"
          
            zap trash: [
              "~/Library/Application Support/<%= name %>",
              "~/Library/Preferences/<%= identifier %>.plist",
            ]
          end
          TEMPLATE
          
          erb = ERB.new(template)
          result = erb.result(binding)
          
          File.write("#{cask_name}.rb", result)
          puts "Generated #{cask_name}.rb"
          puts "Using sha256 :no_check: #{use_no_check}"
          RUBYSCRIPT
          
          echo "Cask file content:"
          cat "$CASK_NAME.rb"
          
          # Basic syntax validation using Ruby
          echo "Validating Ruby syntax..."
          if ruby -c "$CASK_NAME.rb"; then
            echo "✅ Ruby syntax is valid"
          else
            echo "❌ Ruby syntax error"
            exit 1
          fi
          
          # Validate with Homebrew if available (optional)
          if command -v brew &> /dev/null 2>&1; then
            echo "Validating with Homebrew..."
            brew tap homebrew/cask 2>/dev/null || true
            brew style "$CASK_NAME.rb" 2>&1 | head -50 || echo "Style warnings (non-fatal)"
            brew audit --cask "$CASK_NAME.rb" 2>&1 | head -50 || echo "Audit warnings (non-fatal)"
          else
            echo "Homebrew not available, skipping advanced validation"
            echo "Note: Cask will be validated by Homebrew CI after PR creation"
          fi

      - name: Upload Homebrew Cask artifact
        uses: actions/upload-artifact@v4
        with:
          name: homebrew-cask
          path: timetracker.rb
          retention-days: 30

  generate-apt:
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.deb_url != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get app metadata
        id: metadata
        run: |
          PRODUCT_NAME=$(node -p "require('./backend/tauri.conf.json').package.productName")
          DESCRIPTION=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.longDescription")
          SHORT_DESC=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.shortDescription")
          
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "short_description=$SHORT_DESC" >> $GITHUB_OUTPUT
          
          # Package name (lowercase)
          PACKAGE_NAME="timetracker"
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Install dpkg-dev
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev

      - name: Download DEB package
        run: |
          curl -L -o timetracker.deb "${{ needs.prepare-artifacts.outputs.deb_url }}"

      - name: Create APT repository structure
        run: |
          PACKAGE_NAME="${{ steps.metadata.outputs.package_name }}"
          VERSION="${{ needs.prepare-artifacts.outputs.version }}"
          
          # Create directory structure
          mkdir -p apt-repo/dists/stable/main/binary-amd64
          mkdir -p apt-repo/pool/main/t/$PACKAGE_NAME
          
          # Copy DEB to pool
          cp timetracker.deb "apt-repo/pool/main/t/$PACKAGE_NAME/${PACKAGE_NAME}_${VERSION}_amd64.deb"

      - name: Generate Packages file
        run: |
          cd apt-repo
          dpkg-scanpackages --arch amd64 pool/ > dists/stable/main/binary-amd64/Packages
          gzip -k -f dists/stable/main/binary-amd64/Packages

      - name: Generate Release file
        run: |
          cd apt-repo/dists/stable
          
          PACKAGES_SIZE=$(stat -c%s main/binary-amd64/Packages)
          PACKAGES_SHA256=$(sha256sum main/binary-amd64/Packages | cut -d' ' -f1)
          PACKAGES_GZ_SIZE=$(stat -c%s main/binary-amd64/Packages.gz)
          PACKAGES_GZ_SHA256=$(sha256sum main/binary-amd64/Packages.gz | cut -d' ' -f1)
          
          cat > Release << EOF
          Origin: TimeTracker
          Label: TimeTracker APT Repository
          Suite: stable
          Codename: stable
          Version: ${{ needs.prepare-artifacts.outputs.version }}
          Architectures: amd64
          Components: main
          Description: APT repository for TimeTracker - Desktop time tracking application
          Date: $(date -u +"%a, %d %b %Y %H:%M:%S %Z")
          SHA256:
           $PACKAGES_SHA256 $PACKAGES_SIZE main/binary-amd64/Packages
           $PACKAGES_GZ_SHA256 $PACKAGES_GZ_SIZE main/binary-amd64/Packages.gz
          EOF

      - name: Generate installation README
        run: |
          PACKAGE_NAME="${{ steps.metadata.outputs.package_name }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          
          cat > apt-repo/README.md << EOF
          # TimeTracker APT Repository
          
          This repository contains the Debian/Ubuntu packages for TimeTracker.
          
          ## Installation
          
          ### Add the repository
          
          \`\`\`bash
          # Download and add the GPG key (if you have one)
          # curl -fsSL https://your-domain.com/repo.gpg | sudo gpg --dearmor -o /usr/share/keyrings/timetracker.gpg
          
          # Add the repository
          echo "deb [arch=amd64] https://your-domain.com/apt-repo stable main" | sudo tee /etc/apt/sources.list.d/timetracker.list
          
          # Update package list
          sudo apt update
          
          # Install TimeTracker
          sudo apt install $PACKAGE_NAME
          \`\`\`
          
          ## Manual Installation
          
          If you prefer to install manually without adding the repository:
          
          \`\`\`bash
          # Option 1: Download from GitHub Releases
          # Visit: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare-artifacts.outputs.version }}
          # Download the .deb file and install:
          sudo dpkg -i <downloaded-file>.deb
          sudo apt-get install -f
          
          # Option 2: Use the .deb file from this repository
          sudo dpkg -i pool/main/t/$PACKAGE_NAME/${PACKAGE_NAME}_${{ needs.prepare-artifacts.outputs.version }}_amd64.deb
          sudo apt-get install -f
          \`\`\`
          
          ## Repository Structure
          
          This repository follows the standard Debian repository layout:
          
          \`\`\`
          apt-repo/
          ├── dists/stable/main/binary-amd64/
          │   ├── Packages
          │   └── Packages.gz
          ├── pool/main/t/$PACKAGE_NAME/
          │   └── ${PACKAGE_NAME}_<version>_amd64.deb
          └── README.md
          \`\`\`
          
          ## Hosting
          
          To host this repository:
          
          1. Upload the entire \`apt-repo\` directory to a web server with HTTPS
          2. Ensure the web server serves files correctly (no .deb file compression)
          3. Update the installation instructions with your domain
          4. Optionally add GPG signing for enhanced security
          
          For more information, visit: $REPO_URL
          EOF

      - name: Create APT repository archive
        run: |
          cd apt-repo
          tar -czf ../apt-repository.tar.gz .
          cd ..
          zip -r apt-repository.zip apt-repo/

      - name: Upload APT repository artifact
        uses: actions/upload-artifact@v4
        with:
          name: apt-repository
          path: apt-repository.zip
          retention-days: 30

  create-winget-pr:
    needs: [prepare-artifacts, generate-winget]
    if: |
      always() &&
      (needs.prepare-artifacts.result == 'success') &&
      (needs.generate-winget.result == 'success') &&
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_prs == 'true') ||
        (github.event_name == 'release')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for PAT token
        run: |
          if [ -z "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            echo "::warning::PACKAGE_MANAGER_PAT secret is not set. PR creation may fail."
            echo "::warning::To create PRs in external repositories, you need to:"
            echo "::warning::1. Create a Personal Access Token (PAT) with 'repo' scope"
            echo "::warning::2. Add it as a secret named 'PACKAGE_MANAGER_PAT' in repository settings"
            echo "::warning::See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"
          fi
      - name: Download WinGet manifests
        uses: actions/download-artifact@v4
        with:
          name: winget-manifests
          path: ./winget-manifests

      - name: Extract manifests
        run: |
          cd winget-manifests
          unzip -q winget-manifests.zip
          cd ..
          
          # Debug: Show structure
          echo "Manifest structure:"
          find winget-manifests -type f -name "*.yaml" | head -20 || echo "No YAML files found"
          echo "Directory structure:"
          find winget-manifests/manifests -type d | head -20 || echo "No manifests directory found"

      - name: Determine fork repository
        id: winget_fork
        uses: ./.github/actions/determine-fork-owner
        with:
          fork_repo: winget-pkgs
          fork_url: https://github.com/microsoft/winget-pkgs/fork

      - name: Get default branch
        id: get_default_branch_winget
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          FORK_OWNER="${{ steps.winget_fork.outputs.fork_owner }}"
          REPO_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$FORK_OWNER/winget-pkgs")
          DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch // "main"')
          echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT
          echo "Using default branch: $DEFAULT_BRANCH"

      - name: Checkout winget-pkgs repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.winget_fork.outputs.fork_owner }}/winget-pkgs
          token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          path: winget-pkgs
          fetch-depth: 1
          persist-credentials: true
          ref: ${{ steps.get_default_branch_winget.outputs.default_branch }}

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get version
        id: get_version
        uses: ./.github/actions/get-version

      - name: Create branch and copy manifests
        id: create_branch
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          cd winget-pkgs
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="timetracker-$VERSION-$(date +%s)"
          
          # Create new branch
          git checkout -b "$BRANCH_NAME"
          
          # Create directory structure if it doesn't exist
          # Structure: manifests/t/tmtrckr/<PackageName>/<Version>/
          mkdir -p manifests/t/tmtrckr/TimeTracker
          
          # Copy manifests to correct location
          # Structure: manifests/t/tmtrckr/TimeTracker/VERSION/
          if [ -d "../winget-manifests/manifests/t/tmtrckr/TimeTracker/$VERSION" ]; then
            cp -r ../winget-manifests/manifests/t/tmtrckr/TimeTracker/$VERSION manifests/t/tmtrckr/TimeTracker/
          else
            echo "::error::Manifest directory not found: ../winget-manifests/manifests/t/tmtrckr/TimeTracker/$VERSION"
            ls -la ../winget-manifests/manifests/t/ || echo "Manifests directory structure:"
            find ../winget-manifests -type d -name "*tmtrckr*" -o -name "*TimeTracker*" || echo "No manifest directories found"
            exit 1
          fi
          
          # Stage changes
          git add manifests/t/tmtrckr/TimeTracker/$VERSION/
          
          # Commit
          git commit -m "Add TimeTracker version $VERSION"
          
          # Push branch (credentials are persisted from checkout)
          git push origin "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        uses: ./.github/actions/create-pull-request
        with:
          github_token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          fork_owner: ${{ steps.winget_fork.outputs.fork_owner }}
          branch: ${{ steps.create_branch.outputs.branch }}
          base_branch: ${{ steps.get_default_branch_winget.outputs.default_branch }}
          target_repo: microsoft/winget-pkgs
          title: Add TimeTracker version ${{ steps.get_version.outputs.version }}
          body: |
            ## Description
            This PR adds TimeTracker version ${{ steps.get_version.outputs.version }} to the WinGet repository.
            
            ## Changes
            - Added manifests for TimeTracker ${{ steps.get_version.outputs.version }}
            - Installer: MSI package
            - Architecture: x64
            
            ## Checklist
            - [x] Manifest files are correctly formatted
            - [x] Installer URL is valid and accessible
            - [x] SHA256 checksum is correct
            - [x] Silent install switches are configured
            
            ## Related
            Release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag }}

  create-homebrew-pr:
    # DISABLED: Homebrew Cask requires signed and notarized DMG files
    # To enable this job:
    # 1. Set up Apple Developer account and code signing certificates
    # 2. Configure APPLE_CERTIFICATE, APPLE_CERTIFICATE_PASSWORD, APPLE_ID, APPLE_PASSWORD, APPLE_TEAM_ID secrets
    # 3. Update tauri.conf.json with signingIdentity and providerShortName
    # 4. Update release.yml workflow to sign and notarize DMG during build
    # 5. Change the condition below from 'false' to the original condition
    needs: [prepare-artifacts, generate-homebrew]
    if: false
    # Original condition (commented out):
    # if: |
    #   always() &&
    #   (needs.prepare-artifacts.result == 'success') &&
    #   (needs.generate-homebrew.result == 'success') &&
    #   (
    #     (github.event_name == 'workflow_dispatch' && github.event.inputs.create_prs == 'true') ||
    #     (github.event_name == 'release')
    #   )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for PAT token
        run: |
          if [ -z "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            echo "::warning::PACKAGE_MANAGER_PAT secret is not set. PR creation may fail."
            echo "::warning::To create PRs in external repositories, you need to:"
            echo "::warning::1. Create a Personal Access Token (PAT) with 'repo' scope"
            echo "::warning::2. Add it as a secret named 'PACKAGE_MANAGER_PAT' in repository settings"
            echo "::warning::See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"
          fi
      - name: Download Homebrew Cask
        uses: actions/download-artifact@v4
        with:
          name: homebrew-cask
          path: ./homebrew-cask

      - name: Determine fork repository
        id: homebrew_fork
        uses: ./.github/actions/determine-fork-owner
        with:
          fork_repo: homebrew-cask
          fork_url: https://github.com/homebrew/homebrew-cask/fork

      - name: Get default branch
        id: get_default_branch
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          FORK_OWNER="${{ steps.homebrew_fork.outputs.fork_owner }}"
          REPO_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$FORK_OWNER/homebrew-cask")
          DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch // "master"')
          echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT
          echo "Using default branch: $DEFAULT_BRANCH"

      - name: Checkout homebrew-cask repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.homebrew_fork.outputs.fork_owner }}/homebrew-cask
          token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          path: homebrew-cask-repo
          fetch-depth: 1
          persist-credentials: true
          ref: ${{ steps.get_default_branch.outputs.default_branch }}

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get version
        id: get_version
        uses: ./.github/actions/get-version

      - name: Check if cask already exists
        id: check_cask
        run: |
          cd homebrew-cask-repo
          if [ -f "Casks/t/timetracker.rb" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Cask already exists, will update"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "New cask, will create"
          fi

      - name: Create or update cask
        id: create_cask
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          cd homebrew-cask-repo
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="timetracker-$VERSION-$(date +%s)"
          
          # Create new branch
          git checkout -b "$BRANCH_NAME"
          
          # Copy cask file
          cp ../homebrew-cask/timetracker.rb Casks/t/timetracker.rb
          
          # Stage changes
          git add Casks/t/timetracker.rb
          
          # Commit message
          if [ "${{ steps.check_cask.outputs.exists }}" == "true" ]; then
            COMMIT_MSG="Update timetracker to $VERSION"
          else
            COMMIT_MSG="Add timetracker $VERSION"
          fi
          
          git commit -m "$COMMIT_MSG"
          
          # Push branch (credentials are persisted from checkout)
          git push origin "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        uses: ./.github/actions/create-pull-request
        with:
          github_token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          fork_owner: ${{ steps.homebrew_fork.outputs.fork_owner }}
          branch: ${{ steps.create_cask.outputs.branch }}
          base_branch: ${{ steps.get_default_branch.outputs.default_branch }}
          target_repo: homebrew/homebrew-cask
          title: ${{ steps.create_cask.outputs.commit_msg }}
          body: |
            ## Description
            ${{ steps.create_cask.outputs.commit_msg }}.
            
            ## Changes
            - Version: ${{ steps.get_version.outputs.version }}
            - SHA256: Verified
            - URL: Direct download from GitHub Releases
            
            ## Checklist
            - [x] Cask file is correctly formatted
            - [x] SHA256 checksum is correct
            - [x] URL is valid and accessible
            - [x] App bundle name is correct
            
            ## Related
            Release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag }}
