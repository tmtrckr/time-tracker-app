name: Generate Package Manager Manifests

# This workflow generates package manager files (WinGet, Homebrew Cask, APT) and optionally
# creates Pull Requests in the respective repositories.
#
# Triggers:
# - Manual: workflow_dispatch with optional version and create_prs flag
# - Automatic: release event (published) - automatically creates PRs
#
# Prerequisites for PR creation:
# 1. Create forks of the target repositories:
#    - Fork microsoft/winget-pkgs: https://github.com/microsoft/winget-pkgs/fork
#    - Fork homebrew/homebrew-cask: https://github.com/homebrew/homebrew-cask/fork
# 2. Create a Personal Access Token (PAT) with 'repo' scope
# 3. Add PAT as secret 'PACKAGE_MANAGER_PAT' in repository settings
#
# Usage:
# - Manual run: Go to Actions -> Generate Package Manager Manifests -> Run workflow
#   - Set version (optional): e.g., v0.2.3 or leave empty for latest
#   - Set create_prs: true to automatically create PRs in WinGet and Homebrew repos
#   - Set fork_owner (optional): GitHub username who owns the forks (auto-detected from PAT)
# - Automatic: Triggers automatically when a release is published

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.2.3) - leave empty for latest release'
        required: false
        type: string
      create_prs:
        description: 'Automatically create PRs in WinGet and Homebrew repositories'
        required: false
        type: boolean
        default: false
      fork_owner:
        description: 'GitHub username who owns the fork (required for PR creation)'
        required: false
        type: string
  release:
    types: [published]

permissions:
  contents: read
  pull-requests: write

jobs:
  prepare-artifacts:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      msi_url: ${{ steps.get_artifacts.outputs.msi_url }}
      msi_size: ${{ steps.get_artifacts.outputs.msi_size }}
      msi_sha256: ${{ steps.checksums.outputs.msi_sha256 }}
      dmg_url: ${{ steps.get_artifacts.outputs.dmg_url }}
      dmg_size: ${{ steps.get_artifacts.outputs.dmg_size }}
      dmg_sha256: ${{ steps.checksums.outputs.dmg_sha256 }}
      deb_url: ${{ steps.get_artifacts.outputs.deb_url }}
      deb_size: ${{ steps.get_artifacts.outputs.deb_size }}
      deb_sha256: ${{ steps.checksums.outputs.deb_sha256 }}
      release_id: ${{ steps.get_artifacts.outputs.release_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version
        id: get_version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            # Get version from release event
            TAG="${{ github.event.release.tag_name }}"
            VERSION=${TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            # Remove 'v' prefix if present
            VERSION=${VERSION#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          else
            # Get latest release using GitHub API
            LATEST_RELEASE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            LATEST_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
            VERSION=${LATEST_TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $VERSION"

      - name: Get release artifacts
        id: get_artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.get_version.outputs.tag }}
        run: |
          # Get release by tag using GitHub API
          RELEASE_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${TAG}")
          
          RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r '.id')
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          
          # Find MSI file
          MSI_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".msi"))')
          if [ -n "$MSI_ASSET" ] && [ "$MSI_ASSET" != "null" ]; then
            MSI_URL=$(echo "$MSI_ASSET" | jq -r '.browser_download_url')
            MSI_SIZE=$(echo "$MSI_ASSET" | jq -r '.size')
            echo "msi_url=$MSI_URL" >> $GITHUB_OUTPUT
            echo "msi_size=$MSI_SIZE" >> $GITHUB_OUTPUT
            echo "Found MSI: $MSI_URL"
          fi
          
          # Find DMG file
          DMG_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".dmg"))')
          if [ -n "$DMG_ASSET" ] && [ "$DMG_ASSET" != "null" ]; then
            DMG_URL=$(echo "$DMG_ASSET" | jq -r '.browser_download_url')
            DMG_SIZE=$(echo "$DMG_ASSET" | jq -r '.size')
            echo "dmg_url=$DMG_URL" >> $GITHUB_OUTPUT
            echo "dmg_size=$DMG_SIZE" >> $GITHUB_OUTPUT
            echo "Found DMG: $DMG_URL"
          fi
          
          # Find DEB file
          DEB_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets[] | select(.name | endswith(".deb"))')
          if [ -n "$DEB_ASSET" ] && [ "$DEB_ASSET" != "null" ]; then
            DEB_URL=$(echo "$DEB_ASSET" | jq -r '.browser_download_url')
            DEB_SIZE=$(echo "$DEB_ASSET" | jq -r '.size')
            echo "deb_url=$DEB_URL" >> $GITHUB_OUTPUT
            echo "deb_size=$DEB_SIZE" >> $GITHUB_OUTPUT
            echo "Found DEB: $DEB_URL"
          fi

      - name: Download and calculate checksums
        id: checksums
        run: |
          mkdir -p artifacts
          
          # Download MSI and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.msi_url }}" ]; then
            curl -L -o artifacts/installer.msi "${{ steps.get_artifacts.outputs.msi_url }}"
            MSI_SHA256=$(sha256sum artifacts/installer.msi | cut -d' ' -f1)
            echo "msi_sha256=$MSI_SHA256" >> $GITHUB_OUTPUT
            echo "MSI SHA-256: $MSI_SHA256"
          fi
          
          # Download DMG and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.dmg_url }}" ]; then
            curl -L -o artifacts/installer.dmg "${{ steps.get_artifacts.outputs.dmg_url }}"
            DMG_SHA256=$(sha256sum artifacts/installer.dmg | cut -d' ' -f1)
            echo "dmg_sha256=$DMG_SHA256" >> $GITHUB_OUTPUT
            echo "DMG SHA-256: $DMG_SHA256"
          fi
          
          # Download DEB and calculate SHA-256
          if [ -n "${{ steps.get_artifacts.outputs.deb_url }}" ]; then
            curl -L -o artifacts/installer.deb "${{ steps.get_artifacts.outputs.deb_url }}"
            DEB_SHA256=$(sha256sum artifacts/installer.deb | cut -d' ' -f1)
            echo "deb_sha256=$DEB_SHA256" >> $GITHUB_OUTPUT
            echo "DEB SHA-256: $DEB_SHA256"
          fi

  generate-winget:
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.msi_url != ''
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get app metadata
        id: metadata
        run: |
          # Read from tauri.conf.json using PowerShell
          $config = Get-Content -Path "backend\tauri.conf.json" -Raw | ConvertFrom-Json
          
          $PRODUCT_NAME = $config.package.productName
          $DESCRIPTION = $config.tauri.bundle.longDescription
          $SHORT_DESC = $config.tauri.bundle.shortDescription
          
          Add-Content -Path $env:GITHUB_OUTPUT -Value "product_name=$PRODUCT_NAME"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "description=$DESCRIPTION"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "short_description=$SHORT_DESC"
          
          # Publisher name (first letter of product name for manifest path)
          $PUBLISHER = "TimeTracker"
          $PACKAGE_ID = "TimeTracker.TimeTracker"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "publisher=$PUBLISHER"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "package_id=$PACKAGE_ID"

      - name: Create manifest directory structure
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PACKAGE_NAME = "${{ steps.metadata.outputs.product_name }}"
          
          # Create directory: manifests/t/TimeTracker/0.2.3/
          New-Item -ItemType Directory -Force -Path "manifests\t\$PACKAGE_NAME\$VERSION" | Out-Null

      - name: Generate defaultLocale.yaml
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PUBLISHER = "${{ steps.metadata.outputs.publisher }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          $DESCRIPTION = "${{ steps.metadata.outputs.description }}"
          $SHORT_DESC = "${{ steps.metadata.outputs.short_description }}"
          
          $MANIFEST_PATH = "manifests\t\$PRODUCT_NAME\$VERSION\defaultLocale.yaml"
          
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "Version: $VERSION`n"
          $manifestContent += "PackageLocale: en-US`n"
          $manifestContent += "Publisher: $PUBLISHER`n"
          $manifestContent += "PublisherUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "PublisherSupportUrl: https://github.com/${{ github.repository }}/issues`n"
          $manifestContent += "Author: $PUBLISHER`n"
          $manifestContent += "PackageName: $PRODUCT_NAME`n"
          $manifestContent += "PackageUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "License: MIT`n"
          $manifestContent += "LicenseUrl: https://github.com/${{ github.repository }}/blob/main/LICENSE`n"
          $manifestContent += "Copyright: Copyright (c) 2026 bthos`n"
          $manifestContent += "CopyrightUrl: https://github.com/${{ github.repository }}`n"
          $manifestContent += "ShortDescription: $SHORT_DESC`n"
          $manifestContent += "Description: $DESCRIPTION`n"
          $manifestContent += "Tags:`n"
          $manifestContent += "  - time-tracking`n"
          $manifestContent += "  - productivity`n"
          $manifestContent += "  - pomodoro`n"
          $manifestContent += "  - time-management`n"
          $manifestContent += "Moniker: timetracker`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Generate installer.yaml
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          $MSI_URL = "${{ needs.prepare-artifacts.outputs.msi_url }}"
          $MSI_SHA256 = "${{ needs.prepare-artifacts.outputs.msi_sha256 }}"
          
          $MANIFEST_PATH = "manifests\t\$PRODUCT_NAME\$VERSION\installer.yaml"
          
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "Version: $VERSION`n"
          $manifestContent += "InstallerType: msi`n"
          $manifestContent += "Architecture: x64`n"
          $manifestContent += "InstallerUrl: $MSI_URL`n"
          $manifestContent += "InstallerSha256: $MSI_SHA256`n"
          $manifestContent += "InstallerSwitches:`n"
          $manifestContent += "  Silent: `"/quiet`"`n"
          $manifestContent += "  SilentWithProgress: `"/quiet /norestart`"`n"
          $manifestContent += "InstallModes:`n"
          $manifestContent += "  - silent`n"
          $manifestContent += "  - silentWithProgress`n"
          $manifestContent += "Scope: machine`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Generate version.yaml
        run: |
          $VERSION = "${{ needs.prepare-artifacts.outputs.version }}"
          $PACKAGE_ID = "${{ steps.metadata.outputs.package_id }}"
          $PRODUCT_NAME = "${{ steps.metadata.outputs.product_name }}"
          
          $MANIFEST_PATH = "manifests\t\$PRODUCT_NAME\$VERSION\version.yaml"
          
          $manifestContent = "# Created with GitHub Actions`n"
          $manifestContent += "PackageIdentifier: $PACKAGE_ID`n"
          $manifestContent += "Version: $VERSION`n"
          $manifestContent += "DefaultLocale: en-US`n"
          $manifestContent += "ManifestType: version`n"
          $manifestContent += "ManifestVersion: 1.4.0`n"
          
          Set-Content -Path $MANIFEST_PATH -Value $manifestContent -Encoding UTF8

      - name: Create winget manifest archive
        run: |
          Compress-Archive -Path "manifests" -DestinationPath "winget-manifests.zip" -Force

      - name: Upload WinGet manifests artifact
        uses: actions/upload-artifact@v4
        with:
          name: winget-manifests
          path: winget-manifests.zip
          retention-days: 30

  generate-homebrew:
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.dmg_url != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get app metadata
        id: metadata
        run: |
          # Read from tauri.conf.json
          PRODUCT_NAME=$(node -p "require('./backend/tauri.conf.json').package.productName")
          DESCRIPTION=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.longDescription")
          IDENTIFIER=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.identifier")
          
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "identifier=$IDENTIFIER" >> $GITHUB_OUTPUT
          
          # Cask name (lowercase, no spaces)
          CASK_NAME="timetracker"
          echo "cask_name=$CASK_NAME" >> $GITHUB_OUTPUT

      - name: Generate Homebrew Cask file
        run: |
          VERSION="${{ needs.prepare-artifacts.outputs.version }}"
          CASK_NAME="${{ steps.metadata.outputs.cask_name }}"
          PRODUCT_NAME="${{ steps.metadata.outputs.product_name }}"
          DESCRIPTION="${{ steps.metadata.outputs.description }}"
          IDENTIFIER="${{ steps.metadata.outputs.identifier }}"
          DMG_URL="${{ needs.prepare-artifacts.outputs.dmg_url }}"
          DMG_SHA256="${{ needs.prepare-artifacts.outputs.dmg_sha256 }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          
          cat > "$CASK_NAME.rb" << EOF
          # typed: false
          # frozen_string_literal: true
          
          # This file was generated by GitHub Actions
          # Do not edit this file manually
          
          cask "$CASK_NAME" do
            version "$VERSION"
            sha256 "$DMG_SHA256"
          
            url "$DMG_URL"
            name "$PRODUCT_NAME"
            desc "$DESCRIPTION"
            homepage "$REPO_URL"
          
            livecheck do
              url "$REPO_URL"
              strategy :github_latest
            end
          
            app "$PRODUCT_NAME.app"
          
            zap trash: [
              "~/Library/Application Support/$PRODUCT_NAME",
              "~/Library/Preferences/$IDENTIFIER.plist",
            ]
          end
          EOF
          
          echo "Generated $CASK_NAME.rb"

      - name: Upload Homebrew Cask artifact
        uses: actions/upload-artifact@v4
        with:
          name: homebrew-cask
          path: timetracker.rb
          retention-days: 30

  generate-apt:
    needs: prepare-artifacts
    if: needs.prepare-artifacts.outputs.deb_url != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get app metadata
        id: metadata
        run: |
          PRODUCT_NAME=$(node -p "require('./backend/tauri.conf.json').package.productName")
          DESCRIPTION=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.longDescription")
          SHORT_DESC=$(node -p "require('./backend/tauri.conf.json').tauri.bundle.shortDescription")
          
          echo "product_name=$PRODUCT_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "short_description=$SHORT_DESC" >> $GITHUB_OUTPUT
          
          # Package name (lowercase)
          PACKAGE_NAME="timetracker"
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Install dpkg-dev
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev

      - name: Download DEB package
        run: |
          curl -L -o timetracker.deb "${{ needs.prepare-artifacts.outputs.deb_url }}"

      - name: Create APT repository structure
        run: |
          PACKAGE_NAME="${{ steps.metadata.outputs.package_name }}"
          VERSION="${{ needs.prepare-artifacts.outputs.version }}"
          
          # Create directory structure
          mkdir -p apt-repo/dists/stable/main/binary-amd64
          mkdir -p apt-repo/pool/main/t/$PACKAGE_NAME
          
          # Copy DEB to pool
          cp timetracker.deb "apt-repo/pool/main/t/$PACKAGE_NAME/${PACKAGE_NAME}_${VERSION}_amd64.deb"

      - name: Generate Packages file
        run: |
          cd apt-repo
          dpkg-scanpackages --arch amd64 pool/ > dists/stable/main/binary-amd64/Packages
          gzip -k -f dists/stable/main/binary-amd64/Packages

      - name: Generate Release file
        run: |
          cd apt-repo/dists/stable
          
          PACKAGES_SIZE=$(stat -c%s main/binary-amd64/Packages)
          PACKAGES_SHA256=$(sha256sum main/binary-amd64/Packages | cut -d' ' -f1)
          PACKAGES_GZ_SIZE=$(stat -c%s main/binary-amd64/Packages.gz)
          PACKAGES_GZ_SHA256=$(sha256sum main/binary-amd64/Packages.gz | cut -d' ' -f1)
          
          cat > Release << EOF
          Origin: TimeTracker
          Label: TimeTracker APT Repository
          Suite: stable
          Codename: stable
          Version: ${{ needs.prepare-artifacts.outputs.version }}
          Architectures: amd64
          Components: main
          Description: APT repository for TimeTracker - Desktop time tracking application
          Date: $(date -u +"%a, %d %b %Y %H:%M:%S %Z")
          SHA256:
           $PACKAGES_SHA256 $PACKAGES_SIZE main/binary-amd64/Packages
           $PACKAGES_GZ_SHA256 $PACKAGES_GZ_SIZE main/binary-amd64/Packages.gz
          EOF

      - name: Generate installation README
        run: |
          PACKAGE_NAME="${{ steps.metadata.outputs.package_name }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          
          cat > apt-repo/README.md << EOF
          # TimeTracker APT Repository
          
          This repository contains the Debian/Ubuntu packages for TimeTracker.
          
          ## Installation
          
          ### Add the repository
          
          \`\`\`bash
          # Download and add the GPG key (if you have one)
          # curl -fsSL https://your-domain.com/repo.gpg | sudo gpg --dearmor -o /usr/share/keyrings/timetracker.gpg
          
          # Add the repository
          echo "deb [arch=amd64] https://your-domain.com/apt-repo stable main" | sudo tee /etc/apt/sources.list.d/timetracker.list
          
          # Update package list
          sudo apt update
          
          # Install TimeTracker
          sudo apt install $PACKAGE_NAME
          \`\`\`
          
          ## Manual Installation
          
          If you prefer to install manually without adding the repository:
          
          \`\`\`bash
          # Option 1: Download from GitHub Releases
          # Visit: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare-artifacts.outputs.version }}
          # Download the .deb file and install:
          sudo dpkg -i <downloaded-file>.deb
          sudo apt-get install -f
          
          # Option 2: Use the .deb file from this repository
          sudo dpkg -i pool/main/t/$PACKAGE_NAME/${PACKAGE_NAME}_${{ needs.prepare-artifacts.outputs.version }}_amd64.deb
          sudo apt-get install -f
          \`\`\`
          
          ## Repository Structure
          
          This repository follows the standard Debian repository layout:
          
          \`\`\`
          apt-repo/
          ├── dists/stable/main/binary-amd64/
          │   ├── Packages
          │   └── Packages.gz
          ├── pool/main/t/$PACKAGE_NAME/
          │   └── ${PACKAGE_NAME}_<version>_amd64.deb
          └── README.md
          \`\`\`
          
          ## Hosting
          
          To host this repository:
          
          1. Upload the entire \`apt-repo\` directory to a web server with HTTPS
          2. Ensure the web server serves files correctly (no .deb file compression)
          3. Update the installation instructions with your domain
          4. Optionally add GPG signing for enhanced security
          
          For more information, visit: $REPO_URL
          EOF

      - name: Create APT repository archive
        run: |
          cd apt-repo
          tar -czf ../apt-repository.tar.gz .
          cd ..
          zip -r apt-repository.zip apt-repo/

      - name: Upload APT repository artifact
        uses: actions/upload-artifact@v4
        with:
          name: apt-repository
          path: apt-repository.zip
          retention-days: 30

  create-winget-pr:
    needs: [prepare-artifacts, generate-winget]
    if: |
      always() &&
      (needs.prepare-artifacts.result == 'success') &&
      (needs.generate-winget.result == 'success') &&
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_prs == 'true') ||
        (github.event_name == 'release')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Check for PAT token
        run: |
          if [ -z "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            echo "::warning::PACKAGE_MANAGER_PAT secret is not set. PR creation may fail."
            echo "::warning::To create PRs in external repositories, you need to:"
            echo "::warning::1. Create a Personal Access Token (PAT) with 'repo' scope"
            echo "::warning::2. Add it as a secret named 'PACKAGE_MANAGER_PAT' in repository settings"
            echo "::warning::See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"
          fi
      - name: Download WinGet manifests
        uses: actions/download-artifact@v4
        with:
          name: winget-manifests
          path: ./winget-manifests

      - name: Extract manifests
        run: |
          cd winget-manifests
          unzip -q winget-manifests.zip
          cd ..
          
          # Debug: Show structure
          echo "Manifest structure:"
          find winget-manifests -type f -name "*.yaml" | head -20 || echo "No YAML files found"
          echo "Directory structure:"
          find winget-manifests/manifests -type d | head -20 || echo "No manifests directory found"

      - name: Determine fork repository
        id: winget_fork
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ github.event.inputs.fork_owner }}" ]; then
            FORK_OWNER="${{ github.event.inputs.fork_owner }}"
          elif [ -n "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            # Get username from PAT token
            USER_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/user")
            FORK_OWNER=$(echo "$USER_INFO" | jq -r '.login')
          else
            FORK_OWNER="${{ github.repository_owner }}"
          fi
          echo "fork_owner=$FORK_OWNER" >> $GITHUB_OUTPUT
          echo "Using fork owner: $FORK_OWNER"
          
          # Check if fork exists
          FORK_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$FORK_OWNER/winget-pkgs")
          
          if [ "$FORK_CHECK" != "200" ]; then
            echo "::error::Fork repository $FORK_OWNER/winget-pkgs does not exist!"
            echo "::error::Please create a fork of microsoft/winget-pkgs at: https://github.com/microsoft/winget-pkgs/fork"
            echo "::error::Or specify a different fork_owner in workflow inputs"
            exit 1
          fi
          echo "✅ Fork repository $FORK_OWNER/winget-pkgs exists"

      - name: Checkout winget-pkgs repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.winget_fork.outputs.fork_owner }}/winget-pkgs
          token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          path: winget-pkgs
          fetch-depth: 1
          persist-credentials: true

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get version
        id: get_version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            VERSION=${VERSION#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
            VERSION=${TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          else
            LATEST_RELEASE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            LATEST_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
            VERSION=${LATEST_TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Create branch and copy manifests
        id: create_branch
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          cd winget-pkgs
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="timetracker-$VERSION-$(date +%s)"
          
          # Create new branch
          git checkout -b "$BRANCH_NAME"
          
          # Create directory structure if it doesn't exist
          mkdir -p manifests/t/TimeTracker
          
          # Copy manifests to correct location
          # Structure: manifests/t/TimeTracker/VERSION/
          if [ -d "../winget-manifests/manifests/t/TimeTracker/$VERSION" ]; then
            cp -r ../winget-manifests/manifests/t/TimeTracker/$VERSION manifests/t/TimeTracker/
          else
            echo "::error::Manifest directory not found: ../winget-manifests/manifests/t/TimeTracker/$VERSION"
            ls -la ../winget-manifests/manifests/t/ || echo "Manifests directory structure:"
            find ../winget-manifests -type d -name "*TimeTracker*" || echo "No TimeTracker directories found"
            exit 1
          fi
          
          # Stage changes
          git add manifests/t/TimeTracker/$VERSION/
          
          # Commit
          git commit -m "Add TimeTracker version $VERSION"
          
          # Push branch (credentials are persisted from checkout)
          git push origin "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH="${{ steps.create_branch.outputs.branch }}"
          
          PR_BODY=$(cat <<EOF
          ## Description
          This PR adds TimeTracker version $VERSION to the WinGet repository.
          
          ## Changes
          - Added manifests for TimeTracker $VERSION
          - Installer: MSI package
          - Architecture: x64
          
          ## Checklist
          - [x] Manifest files are correctly formatted
          - [x] Installer URL is valid and accessible
          - [x] SHA256 checksum is correct
          - [x] Silent install switches are configured
          
          ## Related
          Release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag }}
          EOF
          )
          
          # Determine fork owner for PR head
          FORK_OWNER="${{ steps.winget_fork.outputs.fork_owner }}"
          HEAD_BRANCH="$FORK_OWNER:$BRANCH"
          
          # Create PR using GitHub API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/microsoft/winget-pkgs/pulls \
            -d "{
              \"title\": \"Add TimeTracker version $VERSION\",
              \"head\": \"$HEAD_BRANCH\",
              \"base\": \"main\",
              \"body\": $(echo "$PR_BODY" | jq -Rs .),
              \"labels\": [\"New-Package\"]
            }")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 201 ]; then
            PR_URL=$(echo "$BODY" | jq -r '.html_url')
            echo "✅ Pull Request created successfully: $PR_URL"
          elif [ "$HTTP_CODE" -eq 422 ]; then
            ERROR_MSG=$(echo "$BODY" | jq -r '.errors[0].message // .message // "Unknown error"')
            echo "::warning::PR may already exist or validation failed: $ERROR_MSG"
            echo "::warning::Branch was created: $BRANCH"
            echo "::warning::You can manually create PR at: https://github.com/microsoft/winget-pkgs/compare/main...$FORK_OWNER:$BRANCH"
          else
            echo "::error::Failed to create PR. HTTP $HTTP_CODE"
            echo "$BODY" | jq '.' || echo "$BODY"
            exit 1
          fi

  create-homebrew-pr:
    needs: [prepare-artifacts, generate-homebrew]
    if: |
      always() &&
      (needs.prepare-artifacts.result == 'success') &&
      (needs.generate-homebrew.result == 'success') &&
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_prs == 'true') ||
        (github.event_name == 'release')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Check for PAT token
        run: |
          if [ -z "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            echo "::warning::PACKAGE_MANAGER_PAT secret is not set. PR creation may fail."
            echo "::warning::To create PRs in external repositories, you need to:"
            echo "::warning::1. Create a Personal Access Token (PAT) with 'repo' scope"
            echo "::warning::2. Add it as a secret named 'PACKAGE_MANAGER_PAT' in repository settings"
            echo "::warning::See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token"
          fi
      - name: Download Homebrew Cask
        uses: actions/download-artifact@v4
        with:
          name: homebrew-cask
          path: ./homebrew-cask

      - name: Determine fork repository
        id: homebrew_fork
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ github.event.inputs.fork_owner }}" ]; then
            FORK_OWNER="${{ github.event.inputs.fork_owner }}"
          elif [ -n "${{ secrets.PACKAGE_MANAGER_PAT }}" ]; then
            # Get username from PAT token
            USER_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/user")
            FORK_OWNER=$(echo "$USER_INFO" | jq -r '.login')
          else
            FORK_OWNER="${{ github.repository_owner }}"
          fi
          echo "fork_owner=$FORK_OWNER" >> $GITHUB_OUTPUT
          echo "Using fork owner: $FORK_OWNER"
          
          # Check if fork exists
          FORK_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$FORK_OWNER/homebrew-cask")
          
          if [ "$FORK_CHECK" != "200" ]; then
            echo "::error::Fork repository $FORK_OWNER/homebrew-cask does not exist!"
            echo "::error::Please create a fork of homebrew/homebrew-cask at: https://github.com/homebrew/homebrew-cask/fork"
            echo "::error::Or specify a different fork_owner in workflow inputs"
            exit 1
          fi
          echo "✅ Fork repository $FORK_OWNER/homebrew-cask exists"

      - name: Checkout homebrew-cask repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.homebrew_fork.outputs.fork_owner }}/homebrew-cask
          token: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
          path: homebrew-cask-repo
          fetch-depth: 1
          persist-credentials: true

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get version
        id: get_version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            VERSION=${VERSION#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
            VERSION=${TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          else
            LATEST_RELEASE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            LATEST_TAG=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
            VERSION=${LATEST_TAG#v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Check if cask already exists
        id: check_cask
        run: |
          cd homebrew-cask-repo
          if [ -f "Casks/t/timetracker.rb" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Cask already exists, will update"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "New cask, will create"
          fi

      - name: Create or update cask
        id: create_cask
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          cd homebrew-cask-repo
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH_NAME="timetracker-$VERSION-$(date +%s)"
          
          # Create new branch
          git checkout -b "$BRANCH_NAME"
          
          # Copy cask file
          cp ../homebrew-cask/timetracker.rb Casks/t/timetracker.rb
          
          # Stage changes
          git add Casks/t/timetracker.rb
          
          # Commit message
          if [ "${{ steps.check_cask.outputs.exists }}" == "true" ]; then
            COMMIT_MSG="Update timetracker to $VERSION"
          else
            COMMIT_MSG="Add timetracker $VERSION"
          fi
          
          git commit -m "$COMMIT_MSG"
          
          # Push branch (credentials are persisted from checkout)
          git push origin "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGE_MANAGER_PAT || secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          BRANCH="${{ steps.create_cask.outputs.branch }}"
          COMMIT_MSG="${{ steps.create_cask.outputs.commit_msg }}"
          
          PR_BODY=$(cat <<EOF
          ## Description
          $COMMIT_MSG.
          
          ## Changes
          - Version: $VERSION
          - SHA256: Verified
          - URL: Direct download from GitHub Releases
          
          ## Checklist
          - [x] Cask file is correctly formatted
          - [x] SHA256 checksum is correct
          - [x] URL is valid and accessible
          - [x] App bundle name is correct
          
          ## Related
          Release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag }}
          EOF
          )
          
          # Determine fork owner for PR head
          FORK_OWNER="${{ steps.homebrew_fork.outputs.fork_owner }}"
          HEAD_BRANCH="$FORK_OWNER:$BRANCH"
          
          # Create PR using GitHub API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/homebrew/homebrew-cask/pulls \
            -d "{
              \"title\": \"$COMMIT_MSG\",
              \"head\": \"$HEAD_BRANCH\",
              \"base\": \"master\",
              \"body\": $(echo "$PR_BODY" | jq -Rs .),
              \"labels\": [\"new cask\"]
            }")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 201 ]; then
            PR_URL=$(echo "$BODY" | jq -r '.html_url')
            echo "✅ Pull Request created successfully: $PR_URL"
          elif [ "$HTTP_CODE" -eq 422 ]; then
            ERROR_MSG=$(echo "$BODY" | jq -r '.errors[0].message // .message // "Unknown error"')
            echo "::warning::PR may already exist or validation failed: $ERROR_MSG"
            echo "::warning::Branch was created: $BRANCH"
            echo "::warning::You can manually create PR at: https://github.com/homebrew/homebrew-cask/compare/master...$FORK_OWNER:$BRANCH"
          else
            echo "::error::Failed to create PR. HTTP $HTTP_CODE"
            echo "$BODY" | jq '.' || echo "$BODY"
            exit 1
          fi
